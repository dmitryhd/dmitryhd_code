<?xml version="1.0" encoding="koi8-r"?>
<!DOCTYPE html
	PUBLIC "-//W3C//DTD XHTML 1.1//EN"
	 "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=koi8-r" />
<title>Fast SMB Search Internals</title>
<link rel="stylesheet" href="/style.css" />
</head>
<body>
<h1>Fast SMB Search</h1>

<h2>Общее устройство</h2>

<p>Всю систему можно условно разделить на 4 относительно независимые части:</p>
<ul>
<li><i>Чекер (checker)</i> - часть, которая наблюдает за состоянием
компьютеров: какие из них включены, какие выключены. Также она ответственна за
добавление новых компьютеров и удаление несуществующих. Результатом работы
чекера является список компьютеров с их состояниями. Чекер работает по
расписанию, но с малыми интервалами - почти все время.</li>
<li><i>Сканер (индексер)</i> -  часть, которая сканирует компьютеры, получает
список  расшаренных каталогов и собирает информацию о находящихся в них файлах.
Результатом этой работы  является список файлов на заданных системой
компьютерах. Сканер также работает по расписанию, но с большими, чем чекер,
временными интервалами.</li>
<li><i>Поисковый сервер (fsearch)</i> - независимо работающий в фоновом режиме
процесс (daemon), который хранит всю информацию о расшаренных файлах и
осуществляет поиск. Сервер работает все время, ожидая запросов. Как только
запрос приходит, сервер обрабатывает его и возвращает требуемую информацию.
Кроме поисковых запросов, сервер может выполнять и служебные, например,
обновлять список файлов или выдавать служебную статистику.</li>
<li><i>CGI-интерфейс</i> - та часть, которая взаимодействует с web-сервером, то
есть с пользователем. Эта часть представляет собой интерфейс поискового
сервера. Она наиболее независима от остальных частей, которые при ее отсутствии
продолжают работать и могут быть эффективно использованы при общении на уровне
непосредственных команд (только с локальной машины).</li>
</ul>

<h2>Храние данных</h2>
<h3>Общая структура данных</h3>
<p>Вся информация, накопленная в результате проверок компьютеров и сканирования
сети, хранится в двух местах: поисковом сервере (fsearch) и SQL-сервере.</p>
<p>Одно из основных назначений поискового сервера - хранить информацию о
файлах.  Также он хранит часть информации о хостах, поскольку она нужна ему для
некоторых целей (например, для возможности сортировки результатов поиска по
состоянию компьютера). Вся информация обо всех файлах лежит в памяти
одновременно. Как следствие, поисковый сервер составляет наиболее
&quot;тяжелую&quot; часть системы, которая потребляет основную долю
процессорного времени и памяти.</p>
<p>SQL-сервер хранит небольшую часть информация - это информация о хостах и их
состоянии, а также различная служебная информация (список рабочих групп,
пользователей, статистика посещений сайта и т. п.). SQL-сервер не выполняет
каких-либо сложных запросов, и все хранящиеся в нем таблицы занимают небольшой
объем.</p>

<h3>Информация о сети и о хостах</h3>
<p>О каждом индексируемом компьютере хранится следующая информация (центральная
таблица hosts):</p>
<ul>
<li>имя хоста (имеется ввиду NetBIOS-имя, а не доменное имя)</li>
<li>IP-адрес</li>
<li>идентификатор рабочей группы</li>
<li>состояние компьютера. Возможны 4 различных состояния: <b>online</b>,
<b>offline</b>, <b>unchecked</b>, <b>error</b>.
<b>online</b> означает, что компьютер включен, доступен, и недавно
проиндексирован (поисковый сервер содержит относительно свежие данные о нем).
<b>offline</b> означает, что компьютер выключен. <b>unchecked</b> означает, что
компьютер включен, однако либо он только что включился и его еще не успели
просканировать, либо его уже давно не сканировали и потому данные о нем
устарели. Состояние <b>unchecked</b> - временное, существует только до запуска
сканера. Обнаружив компьютер в таком состоянии, сканер примется его
индексировать. Состояние <b>error</b> означает, что компьютер включен, однако
просканировать его не удалось (в подавляющем большинстве случаев это означает
запрет доступа или превышение ограничения по числу подключенных
пользователей).</li>
<li>время последней проверки статуса компьютера (ставится чекером)</li>
<li>время последнего сканирования компьютера (ставится сканером)</li>
<li>время, когда компьютера был последний раз замечен включенным</li>
<li>время, когда компьютера был последний раз замечен выключенным</li>
</ul>
<p>В таблице workgroups хранится информация о рабочих группах в сети: ее имя и
идентификатор.</p>
<p>Также имеется ряд вспомогательных таблиц: counter - для подсчета числа
посещения различных страниц; stat - для быстрого доступа к статистике по
различным компьютерам и типам ресурсов.</p>

<h3>Информация о файлах</h3>
<p>Информация о файлах хранится в поисковом сервер в виде структур, в которых имеется следующие поля:</p>
<ul>
<li>имя файла</li>
<li>идентификатор - внутренний номер (целое число типа int),
присваиваемый каждому файлу. Уникален в пределах одного компьютера,
корневой каталог всегда имеет идентификатор 0.</li>
<li>ссылка на каталог, содержащий файл (хранится как идентификатор родительского каталога).</li>
<li>атрибуты - на данный момент поддерживается только один - является ли файл каталогом.</li>
<li>размер файла (64-битное число). Для каталогов в этом поле хранится размер всех подкаталогов.</li>
<li>тип ресурса.</li>
</ul>
<p>Тип ресурса введен для возможности быстрого поиска только в определенном типе файлов.
На данный момент выделены такие типы: <i>фильмы, клипы, музыка, картинки,
	документация, файлы Unix, образы дисков</i>.  Тип файла представляет из
себя число, 0 означает неклассифицированный файл, положительное число означает
определенный тип. Список типов можно легко изменить или расширить, поисковый
сервер воспринимает тип ресурса лишь как произвольное целое число (аналог
вычислимого поля в SQL-таблицах).  Файлы делятся на типы по их расширению и
размеру. Поисковый сервер содержит внутри себя классификатор, который
проставляет тип ресурса при загрузке списка файлов с диска.</p>

<h2>Host checker</h2>
<p>Checker представляет из себя скрипт, запускающийся по расписанию (при помощи
cron) и определяющий какие компьютеры включены и выключены. Получив свежую
информацию, он заполняет таблицу hosts в SQL-сервере, а также синхронизирует
данные о компьютерах в поисковом сервере.</p>
<p>Для определения включенных компьютеров checker использует утилиту
<b>nmap</b>. Он запускает ее, передавая различные подсети, указанные в
конфигурационных файлах. Для проверки включенности компьютера использует TCP
scan на 139 порт. Все ответившие на этот запрос считаются включенными.</p>
<p>После этого определяется статус компьютеров. Выключенный компьютер сразу
получается статус <b>offline</b>.  Компьютер, который раньше был выключен, а
сейчас стал включенным (только что включился) получает статус <b>unchecked</b>.
Если компьютер был включен, и по-прежнему остается включен, то проверяется
время его последнего сканирования.  Если компьютер недавно просканирован, его
состояние не меняется. Если последний раз компьютеры был просканирован давно,
то ему тоже ставится статус <b>unchecked</b>. Устанавливая статус
<b>unchecked</b>, checker выбирает компьютеры, которые в ближайший запуск будут
сканироваться сканером.</p>

<h2>Сканнер</h2>
<p>Сканер тоже запускается по расписанию, но реже (например, раз в 15 минут).
Сканер выбирает из списка компов имеющие статус <b>unchecked</b>, то есть те,
которые включены и данные о которых устарели, и начинает их сканировать.</p>
<p>Для сканирования используется патченный smbclient, который отличается от
обычного тем, что выводит информацию не в stdout в виде удобном для
пользователя, а в файл, указанный в командной строке, и и в специальном
формате, удобном для чтения из поискового сервера.  Сначала получается список
расшаренных каталогов, а затем они сканируются по порядку (вся информация
дописывается в один список файлов). Если сканирование окончилось неуспешно
(smbclient вернул ошибку), то компьютеру ставится статус <b>error</b>. Если
компьютер был успешно просканирован, то сканер отправляет список файлов
поисковому серверу (указывая запрос на обновление). Поисковый сервер читает
список файлов в память, делая различные проверки, строя индексы, классифицируя
файлы и обновляя статистику.</p>
<p>Во избежание различных конфликтов, сканер при запуске создает специальный
.lock-файлы, чтобы не запустились 2 экземпляра сканера одновременно.</p>

<h2>Поисковый сервер</h2>
<h3>Общее устройство</h3>
<p>Поисковый сервер (fsearch) представляет собой наиболее технически сложный
компонент всей системы. Он написан на C++ в виде демона, который запускается и
находится в памяти все время в течение работы. При перезапуске чекера, сканера,
web-сервера его перезапускать не нужно. При разработке поискового сервера
использовался valgrind и другие средства с целью уничтожения всех утечек памяти
и обеспечения стабильной работы. В целом можно сказать, что эта цель
достигнута.</p>
<p>
Все общение с поисковым сервером происходит через сокет. Может использоваться
любой тип сокета (UNIX, TCP/IP, другие), никаких специфичных функций не
используется.  В данный момент применяется UNIX-сокет по причине своей
простоты. Если вдруг возникнет необходимость для доступа к нему по сети
(например, поисковый сервер и web-сервер может быть на разных машинах), то
легко добавить TCP/IP-сокет.</p>
<p>
Через сокет сервер принимает запросы и делает соответствующие действия. Если
запрос подразумевает некоторый ответ, то сервер выдает ответ прямо в этот сокет
же. Все команды передаются по строчкам, разделителем является символ конца
строки <tt>\n</tt>. Запросы можно условно разделить на несколько типов:</p>
<ul>
<li>запросы на поиск - в данный момент этот один запрос <tt>SEARCH</tt></li>
<li>обновление данных - команды, указывающие на изменение состояние (обновление
списка файлов для хоста, добавление нового или удаление старого компьютера и др.).</li>
<li>служебная информации - вспомогательные команды для сбора статистики (информация
о внутреннем состоянии сервера, статистика по разным типам файлов.</li>
</ul>

<h3>Поисковые запросы</h3>

<p>Поисковые запросы содержат в себе <i>тест</i>, или <i>фильтр</i>
которое указывает какие файлы интересуют пользователя. Условие есть
выражение, которое строится из базовых тестов и различных логических
операций. Базовые тесты включают в себя следующие:</p>
<ul>
<li>SUBSTR &quot;str&quot; - наличие подстроки в строке, пожалуй
основной используемый тест;</li>
<li>RES_TYPE num - принадлежность файла к определенному типу;</li>
<li>MINSIZE, MAXSIZE - проверка на то, что размер файла больше или
меньше заданного размера;</li>
<li>ISDIR - является ли файл каталогом.</li>
</ul>
<p>Для сложных поисков применяются различные логические операторы (AND, NOT,
OR, XOR) и скобки. Например, запрос, который ищет музыкальный файлы Pink Floyd
размера не менее 10 Mb может выглядеть так:</p>
<pre>
	(SUBSTR "Pink Floyd") AND (RESTYPE 2) AND (MINSIZE 10000000)
</pre>
<p>Для реализации тестов были применены методы объектно-ориентированного
программирования. Каждый тест реализован классом, унаследованным от базового
абстрактного теста.  Это позволяет очень просто создавать новые тесты:
достаточно объявить новый класс и перегрузить в нем виртуальную функцию test.
</p>

<h3>Синтаксис запросов</h3>
<p>Все поисковые запросы, обрабатываемые сервером, имеют следующий вид:</p>
<p>
<code>
	SEARCH min max [SHORT|FULL] hostfilter query
</code>
</p>
<p>
Где:
</p>
<ul>
<li>min и max указывают какой диапазон результатов нужен. Например, если в
результате поиска находится 50000 файлов, то пользователь может смотреть их
постранично, по 100 штук за один раз. Такая организация используется потому,
что смотреть 50000 файлов одновременно неудобно. Большинство браузеров при этом
съедают всю оперативную память и уходят в глубокий своп, что отнюдь не радует
пользователя. Также создается избыточная нагрузка на web-сервер и скрипты
осуществляющие вывод. По этой причине имеет смысл ограничивать количество
одновременно выдаваемых результатов.</li>
<li>SHORT или FULL указывает нужна ли полная или краткая информация о файлах.
Обычно при поиске файлов используется полная информация. Наоборот, при
получении списка файлов в одном каталоге используется краткая форма, так как
большая часть информации (пусть, имя хоста) будет одинаковое (и заранее
известное).</li>
<li>hostfilter определяет условие, накладываемое на хост. Например, это может
быть условие для поиска только среди включенных компьютеров, или машин,
находящихся в одной рабочей подгруппе.</li>
<li>query задает собственно условие поиска.</li>
</ul>

<h3>Запросы с просмотром пути</h3>
<p>Для более полных возможностей поиска были реализованы так называемые
<i>запросы с обходом полного пути</i>. При типичном поиске рассматривается
только имя файла, имя каталогов, содержащих файл не учитывается. Довольно
типичны такие ситуации: \\HOST\share\music\Artist\Album\Song.mp3.  При этом
пользователи ищут слова Artist Album Song. Никаких файлов при этом не
находится, так как имя файла Song.mp3 содержит только ключевое слово Song. Для
преодоления этого был введен специальный режим, который позволяет просматривать
имена родительских каталогов.</p>
<p>Дело в том, что информация о файлах сама по себе уже занимает достаточно
много места, поэтому хранить полный путь невозможно (это будет требовать
гигабайты оперативной памяти).  По этой причине, полный путь всегда
конструируется на лету. Необходимо обеспечить чтобы поиск при этом не сильно
замедлялся. Для решения этой задачи были придуманы фильтры с состояниями (state
filters).  Обычный фильтр является двоичным, его функция проверки возвращает
true или false в зависимости от того, подходит файл или нет.  State filter
устроен более тонко - он имеет состояние, которое показывает какая часть
фильтра уже была найдена. При этом функция добавочной проверки, которая
добавляет новое слово (элемент пути) и обновляет состояние. Изначально фильтр
инициализируется пустым состоянием. Если по окончании он будет в состоянии,
когда все его условия удовлетворены (полное состояние), то его функция проверки
возвращает true.  Применение функций состояния позволяет не проверять заново
весь пусть, а запоминать состояние родителя и затем только добавлять имя
конечного файла. Это дает очень существенный выигрыш в скорости. Замеры
показывают, что накладные расходы при таком способе минимальны.</p>
<p>Был реализован специальный path match filter, который, используя метод
состояний, позволяет проверять заданные тесты по полному пути. Состояние
реализуется в виде битовой маски (до 32-х тестов).
Для его использования используется следующий синтаксис:
</p>
<p>
<code>
PATHMATCH(TEST1, TEST2, ..., TESTN)	
</code>
</p>
<p>Например, для вышеописанной ситуации можно использовать тест
PATHMATCH(SUBSTR "Artist", SUBSTR "Album", SUBSTR "Song")
</p>

<h3>Оптимизация запросов с помощью индексов</h3>
<p> Вначале общее количество файлов было мало и простой проверка всех файлов
подряд работала вполне быстро (0.2 с). По мере увеличения числа хостов и роста
базы такой метод становился все медленнее и медленнее. Для решения этой
проблемы было принято решение об использовании индексов.</p>
<p> Основная трудность в такого рода системах - как правильно строить индексы.
Для размера, даты, типа файла индексы строятся очевидным способом. Но строки не
являются строго упорядоченными, поэтому отсортировать их в порядке возрастания
невозможно. Для поиска по строкам применяются специальные структуры данных -
суффиксные деревья, trie, PATRICIA-деревья и т.п. Основная проблема состоит в
том, что эти структуры занимают очень много места в памяти, или очень долго
строятся.  Особенность поиска в локальной сети состоит в том, процесс
пересканирования идет постоянно (в среднем 1 хост в минуту), что накладывает
требования на очень быстрое обновление индекса.  </p>
<p> Чтобы удовлетворить всем требованиям - маленький объем памяти и быстрое
обновление был применен метод индексирования по словам. Для этого каждое имя
файла разбивается на слова. Затем строится список какие слова содержатся в
каких файлах. Подсчеты показывают, что часто используемые слова (the, on, of)
составляют более 50% индекса что сильно увеличивает расход памяти. Поскольку
поиск по ним обычно бессмысленен то, индекс для них просто не строится.  </p>
<p> В отличие от настоящего индекса, который содержит точную информацию, здесь
индекс дает лишь приблизительную. Например, буквосочетание "pink floyd"
дробится на слова pink floyd. Однако не всякое имя, содержащие cлова pink и
floyd обязательно содержит "pink floyd" (например floyd pink). Поэтому вместо
термина индекс здесь применяется понятие подсказки (hint). Подсказка -
подмножество файлов, гарантированно содержащее все файлы, удовлетворяющие
некоторому условию, но возможно также содержащее еще какие-то лишние
ненужные файлы. При поиске теста сначала строится hint, а затем тест
проверяется только внутри него. При поиске подстрок используется метод
разбиения на слова.  В момент реализации использование hint-ов ускорило поиск в
8-9 раз (основное время теперь тратится на проверку слов).  </p>

<h3>Использование памяти</h3>
<p> Один из наиболее важных моментов состоит в том, что почти все данные,
которые находятся в памяти поискового сервера, постоянно используются. Когда
свободной физической памяти становится недостаточно и сервер весь не влезает в
память, работать с ним просто невозможно. Это не есть проблема неправильно
написанного сервера, для поиска действительно необходимо одновременно работать
с большим числом данных. При установке поискового сервера это обстоятельство
нужно учитывать и не пытаться ставить его на машину с недостаточным объемом
памяти.</p>
<p>Память расходуется в основном на 2 большие структуры данных. Первая из них -
непосредственно сама информация о файлах. Для каждого файла нужно 28 байт + имя
файла. Средняя длина имени файла - 12.8 (+1 байт на закрывающий нуль). Всего
получается около 32 байта на файл. В используемой конфигурации наблюдается на
данный момент около 12 миллионов файлов, что дает 400 Мб.</p>
<p>Второй источник высокого потребления памяти - индексы и хэш слов. Размер
индекса равен примерно 8 байта x общее количество слов. В среднем в одном файле
попадается 1.5 слова, что дает еще 12 байт на файл. Хэш слов также занимает
большой объем, но в отличии от предыдущих этот объем почти не растет с
увеличением количества файлов. При увеличении количества файлов с 10 миллионов
до 17 миллионов количество слов выросло на проценты и сейчас составляет около
600 тысяч.  Можно считать, что эта часть занимает фиксированный объем.  </p>
<p>Суммарное использование памяти сервером можно узнать при помощи команды
SERVERSTAT или скрипта serverstat.pl при работе с Web-интерфейсом</p>

<h2>Web-интерфейс</h2>
<p>Web-интерфейс представляет собой набор CGI-скриптов, взаимодействующих с
web-сервером Apache и поисковым сервером FSearch. Основная их задача
обработтка параметров, которые ввел пользователь, проверка их правильности,
составление запроса к поисковому серверу и затем красивый вывод результатов в
виде html. Для обращения к поисковому серверу используется обычный UNIX-сокет,
для интерфейса к web-серверу - модуль CGI.pm, который входит в поставку Perl.
</p>
<p> Для ускорения работы используется mod_perl, который позволяет запускать
perl-скрипты прямо внутри Apache, без дополнительных fork/exec. При этом сам
скрипт представляется в виде процедуры, которую можно запускать много раз без
инициализации самого perl (что весьма длительная процедура).</p>
<p> Для повышения быстродействия используется Apache 2, который позволяет
запускать различные обработчики в виде различных тредов, что ускоряет
переключение задач и уменьшает расход памяти. Переход с Apache 1.3 на Apache
2.0 дал ощутимый прирост скорости.</p>


<hr />
<p><b>Fast SMB Search</b> is written by Sasha, write to
<a href="mailto:alex@sectorb.msk.ru">alex@sectorb.msk.ru</a></p>
</body></html>
